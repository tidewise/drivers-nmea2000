#include "PGNs.hpp"
#include <nmea2000/Decode.hpp>

using namespace nmea2000::decode;
using namespace nmea2000::pgns;

<% definitions.each do |pgn| %>
<% existing_structs = Set.new %>
<%     struct_basename = struct_name = Codegen.pgn_name_to_cxx(pgn.name) %>
<%     struct_name_i = 0 %>
<%     until existing_structs.add?(struct_name) %>
<%         struct_name = "#{struct_basename}#{struct_name_i += 1}" %>
<%     end %>
<%= struct_name %> <%= struct_name %>::fromMessage(Message const& message) {
    if (message.pgn != ID) {
        throw std::invalid_argument("unexpected PGN ID");
    }
    else if (message.size != BYTE_LENGTH) {
        throw std::invalid_argument("unexpected payload size");
    }

    <%= struct_name %> result;

<%
        Codegen.pgn_fields_to_cxx(pgn).each do |field, field_type, field_name|
            bit_offset = field.bit_offset
            byte_offset = field.byte_offset
            relative_bit_offset = field.relative_bit_offset
            byte_length_in_bits = field.byte_length * 8;
%>
<%          if field.unsigned? %>
    result.<%= field_name %> = decode<%= byte_length_in_bits %>(
        &message.payload[<%= byte_offset %>]
    ) >> <%= relative_bit_offset %>;
<%          else %>
    auto <%= field_name %>_raw = decode<%= byte_length_in_bits %>(
        &message.payload[<%= byte_offset %>]
    );
    result.<%= field_name %> = reinterpret_cast<<%= field_type %> const&>(
        <%= field_name %>_raw
    );
<%          end %>
<%      end %>
    return result;
}
<% end %>
